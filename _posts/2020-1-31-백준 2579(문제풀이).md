---
layout: post
title: BAEKJOON 2579
---

# 문제
> 계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.  

<div>
    <img width="313" alt="스크린샷 2020-01-31 오후 11 44 47" src="https://user-images.githubusercontent.com/37113547/73548265-cf724b00-4483-11ea-92de-e53451359867.png">
</div>  

> 예를 들어 <그림 2>와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.  

<div>
    <img width="313" alt="스크린샷 2020-01-31 오후 11 44 53" src="https://user-images.githubusercontent.com/37113547/73548268-d0a37800-4483-11ea-83c7-fafce860c47d.png">
</div>  
계단 오르는 데는 다음과 같은 규칙이 있다.  
계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.  
연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.  
마지막 도착 계단은 반드시 밟아야 한다.  
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.  
각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.  

# 입력
> 입력의 첫째 줄에 계단의 개수가 주어진다.  
둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.  

-----
### 나의 처음 코드
>  동적 계획법에 대한 대체적인 내용들이 머릿속에서 쉽게 자리잡히지 않아서 처음에 문제를 접할 때 어려움이 있었다. 

~~~python
N = int(input())
num_list = [list(map(int, input().split())) for i in range(N)]
# print(num_list)
dp_list = [[num_list[0][0]+num_list[1][0], num_list[0][0]+num_list[1][1]]]
# print(dp_list)
for i in range(2, N):
    tmp_list = []
    idx = 0
    cnt = 0
    for j in dp_list[0]:
        if j != -1:
            if j + num_list[i][idx] > j + num_list[i][idx+1]:
                tmp_list.append(j+num_list[i][idx])
                tmp_list.append(-1)
                idx += 1
            else:
                tmp_list.append(-1)
                tmp_list.append(j+num_list[i][idx+1])
                idx += 1
        else:
            tmp_list.append(-1)
            tmp_list.append(-1)
    dp_list.clear()
    dp_list.append(tmp_list)
    
print(max(dp_list[0]))
~~~
> 결과는 ***메모리 초과***.  공식을 세우면서 느낀거지만 당연히 메모리 초과가 난다는 것을 예감했다,,, n층에는 2의 n승으로 커지기 떄문이다. 2의 500승은 상상도 하기 싫은 숫자일 것이다... 자, 그러면 방식을 바꿔서 생각해보자.  
새로운 리스트로 메모리를 낭비하기 보다, 비슷한 방식으로 주어진 메모리를 이용하면 어떨까???! 코드는 아래와 같다.

~~~python
N = int(input())
num_list = [list(map(int, input().split())) for i in range(N)]

for i in range(N-1, 0, -1):
    for j in range(i):
        if num_list[i][j] > num_list[i][j+1]:
            num_list[i-1][j] += num_list[i][j]
        else:
            num_list[i-1][j] += num_list[i][j+1]
            
print(num_list[0][0])
~~~
-----  
> 일단 결과는 ***맞았습니다.*** !!. 아까랑 다른 점을 눈치채겠는가!? 새로운 리스트를 만드는 것이아니라, 입력값을 받은 리스트에서 아래로 내려가면서, 더해주면서 바꾸는 것이다. 간단한 예시를 들자면,  
>>1  
2  4
> 저렇게 구성되어 있을 경우 다음 단계는  
>>1  
3  5
> 이런식으로 더해지면서 바뀌는 것이다. 조건은 더할 수 있는 것중에 큰것을 더하면된다. 그러면 제일 아래에 남는 숫자들을 후보들의 집합이 되는 것이다. 그러면 최대 메모리는 N(N-1)/2 가 되므로 아까보다 더 절약할 수 있게 된다!!
