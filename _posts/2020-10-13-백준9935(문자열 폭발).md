---
layout: post
title: BAEKJOON 9935
---

# 문제
> 상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.  
폭발은 다음과 같은 과정으로 진행된다.  
  
>>문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.
>>새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.
>>폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.
>>상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 "FRULA"를 출력한다.  
  
폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.

# 입력
> 첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.  
둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.  
두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.  

# 출력
> 첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.  

-----
### 나의 코드

> 이번 문제는 스택 자료구조를 사용하는게 핵심이다. 그러나 폭발문자열을 만났을 때 일치하는 문자열을 확인하고 폭바시켜야 한다! 폭발 문자열의 시작문자와 같은 부분을 찾아서 폭발을 시키게 된다면, 시간초과가 날 것이다.  
그러면, 어떠한 아이디어가 있을까? 폭발 문자열의 시작을 체크하기보다는! 폭발 문자열의 끝과 동일한 문자가 들어온다면 스택안에서 폭발문자열-1 만큼 확인해주면 된다.  
코드는 다음과 같다!  

~~~python
input_str = input() #들어오는 문자열
find_str = input() #폭발 문자열
findStr_len = len(find_str) #폭발 문자열 길이
stack = [] #들어오는 문자열이 쌓일 스택

for char in input_str:
    #폭발 문자열의 끝과 같고, 스택안의 길이가 폭발문자열-1 보다 많다면
    if char == find_str[-1] and len(stack) >= findStr_len -1:
        idx = 0 #폭발문자열 인덱스
        flag = False #폭발이 된다면 True
        #하나씩 체크해주기
        for i in range(len(stack)-findStr_len+1, len(stack)):
            if stack[i] != find_str[idx]:
                flag = True
                break
            idx += 1
        #폭발이 안된다면
        if flag:
            stack.append(char)
        #폭발이 된다면
        else:
            for i in range(findStr_len-1):
                stack.pop()
    else:
        stack.append(char)
        

if len(stack) != 0:
    print(''.join(stack))
else:
    print("FRULA")
~~~
-----
