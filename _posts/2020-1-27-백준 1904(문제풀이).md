---
layout: post
title: BAEKJOON 1904
---

# 문제
지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.  
어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.  
그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.  
우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.  

# 입력
> 첫 번째 줄에 자연수 N이 주어진다.(N ≤ 1,000,000)

-----
### 나의 처음 코드
>  저번 포스팅(2748)에서 다룬 피보나치 문제랑 별반 다를게 없다. 다만 이번에는, 계산할 때 사용된 0과 1의 갯수를 카운트 해서 구하라는 문제이다. 머릿속으로 5을 구할 때 필요한 0과 1의 갯수와 3과4를 구할 때 필요한 0과 1의 갯수를 따져보면 이 또한 피보나치 수열을 따르는 것을 볼 수 있다. 그 과정을 담은 코드는 다음과 같다.

~~~python
n = int(input())
num_list = []
num_of_zero = [1,0,1]
num_of_one = [0,1,1]

def get_count(nth : int):
    global num_of_one
    global num_of_zero
    #원하는 값이 이미 구해져있다면 pass
    if len(num_of_one) >= nth + 1:
        pass
    else:
        for i in range(len(num_of_one), nth+1):
            num_of_one.append(num_of_one[i-1] + num_of_one[i-2])
            num_of_zero.append(num_of_zero[i-1] + num_of_zero[i-2])
      
#get_count를 통해 num_of_zero와 num_of_one의 갯수를 차례로 채우고, 다음에 input이 존재하면 같은 과정을
#반복 하지 못하게 해주는 작업
for i in range(n):
    num_list.append(int(input()))
    get_count(num_list[-1])
    
#정답 프린트
for i in num_list:
    print(num_of_zero[i], num_of_one[i])
~~~
> 결과는 ***맞았습니다***. 저번 피보나치 포스팅 문제랑 다를게 없는 문제이다. 이 문제로는 아직까지 DP의 매력을 못 느낄 수도 있다! 허나 걱정 안해도 된다. 느므 믄타 :(

